================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-01T16:48:05.794Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
.npmrc
.prettierignore
.prettierrc
eslint.config.js
package.json
postcss.config.js
README.md
src/app.d.ts
src/app.html
src/app.pcss
src/lib/components/ChapterCard.svelte
src/lib/components/FileUpload.svelte
src/lib/components/FloatingActionButton.svelte
src/lib/components/Navbar.svelte
src/lib/components/ProgressBar.svelte
src/lib/components/QuestionModal.svelte
src/lib/components/TableOfContents.svelte
src/lib/components/ThemeToggle.svelte
src/lib/index.ts
src/lib/utils/markdown.js
src/lib/utils/theme.js
src/lib/vectorStore.js
src/routes/+layout.svelte
src/routes/+page.svelte
src/routes/api/openai/+server.js
src/routes/api/upload/+server.js
svelte.config.js
tailwind.config.js
tsconfig.json
vite.config.ts

================================================================
Repository Files
================================================================

================
File: .gitignore
================
node_modules

# Output
.output
.vercel
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*

================
File: .npmrc
================
engine-strict=true

================
File: .prettierignore
================
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock

================
File: .prettierrc
================
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-svelte"],
	"overrides": [{ "files": "*.svelte", "options": { "parser": "svelte" } }]
}

================
File: eslint.config.js
================
import js from '@eslint/js';
import ts from 'typescript-eslint';
import svelte from 'eslint-plugin-svelte';
import prettier from 'eslint-config-prettier';
import globals from 'globals';

/** @type {import('eslint').Linter.Config[]} */
export default [
	js.configs.recommended,
	...ts.configs.recommended,
	...svelte.configs['flat/recommended'],
	prettier,
	...svelte.configs['flat/prettier'],
	{
		languageOptions: {
			globals: {
				...globals.browser,
				...globals.node
			}
		}
	},
	{
		files: ['**/*.svelte'],
		languageOptions: {
			parserOptions: {
				parser: ts.parser
			}
		}
	},
	{
		ignores: ['build/', '.svelte-kit/', 'dist/']
	}
];

================
File: package.json
================
{
	"name": "ai-teacher",
	"version": "0.0.1",
	"private": true,
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"lint": "prettier --check . && eslint .",
		"format": "prettier --write ."
	},
	"devDependencies": {
		"@sveltejs/adapter-auto": "^3.0.0",
		"@sveltejs/kit": "^2.0.0",
		"@sveltejs/vite-plugin-svelte": "^3.0.0",
		"@tailwindcss/typography": "^0.5.15",
		"@types/eslint": "^9.6.0",
		"autoprefixer": "^10.4.20",
		"daisyui": "^4.12.10",
		"eslint": "^9.0.0",
		"eslint-config-prettier": "^9.1.0",
		"eslint-plugin-svelte": "^2.36.0",
		"globals": "^15.0.0",
		"postcss": "^8.4.41",
		"prettier": "^3.1.1",
		"prettier-plugin-svelte": "^3.1.2",
		"svelte": "^4.2.7",
		"svelte-check": "^3.6.0",
		"tailwindcss": "^3.4.10",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.0.0",
		"vite": "^5.0.3"
	},
	"type": "module",
	"dependencies": {
		"@langchain/openai": "^0.2.8",
		"@supabase/supabase-js": "^2.45.2",
		"dompurify": "^3.1.6",
		"dotenv": "^16.4.5",
		"highlight.js": "^11.10.0",
		"langchain": "^0.2.17",
		"marked": "^14.1.0",
		"openai": "^4.56.1",
		"pdf-parse": "^1.1.1",
		"pdf.js-extract": "^0.2.1",
		"uuid": "^10.0.0"
	}
}

================
File: postcss.config.js
================
import tailwindcss from 'tailwindcss';
import autoprefixer from 'autoprefixer';

export default {
	plugins: [tailwindcss, autoprefixer]
};

================
File: README.md
================
# create-svelte

Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/main/packages/create-svelte).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

```bash
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app
```

## Developing

Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn`), start a development server:

```bash
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

## Building

To create a production version of your app:

```bash
npm run build
```

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.

================
File: src/app.d.ts
================
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

================
File: src/app.html
================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>

================
File: src/app.pcss
================
@tailwind base;
@tailwind components;
@tailwind utilities;

.w-full {
	width: 100%;
}
.max-w-2xl {
	max-width: 2xl;
}
.mx-auto {
	margin-left: auto;
	margin-right: auto;
}
.text-center {
	text-align: center;
}

================
File: src/lib/components/ChapterCard.svelte
================
<!-- src/lib/components/ChapterCard.svelte -->
<script>
	import { slide } from 'svelte/transition';
	import { parseMarkdown } from '$lib/utils/markdown';

	export let item;
	export let index;

	let expanded = true;

	function toggleExpand() {
		expanded = !expanded;
	}
</script>

<div class="card bg-base-100 shadow-xl mb-4 rounded-lg overflow-hidden w-full" data-index={index}>
	<div class="card-body p-0">
		<button class="w-full text-left p-4 bg-primary text-primary-content" on:click={toggleExpand}>
			<h2 class="card-title flex justify-between items-center">
				{item.title}
				<span class="transition-transform duration-300 {expanded ? 'rotate-180' : ''}">â–¼</span>
			</h2>
		</button>
		{#if expanded}
			<div class="p-4 prose max-w-none" transition:slide={{ duration: 300 }}>
				{@html parseMarkdown(item.content)}
			</div>
		{/if}
	</div>
</div>

================
File: src/lib/components/FileUpload.svelte
================
<script>
	import { createEventDispatcher } from 'svelte';
	import { fade } from 'svelte/transition';

	const dispatch = createEventDispatcher();

	let files = [];
	let uploading = false;
	let uploadProgress = 0;
	let uploadStatus = '';
	let processingProgress = 0;

	async function handleFileSelect(event) {
		const selectedFiles = Array.from(event.target.files);
		uploading = true;
		uploadProgress = 0;
		processingProgress = 0;
		uploadStatus = 'Starting upload...';

		for (const file of selectedFiles) {
			const formData = new FormData();
			formData.append('file', file);

			try {
				const response = await fetch('/api/upload', {
					method: 'POST',
					body: formData
				});

				if (!response.ok) {
					throw new Error('File upload failed');
				}

				const reader = response.body.getReader();
				const decoder = new TextDecoder();

				while (true) {
					const { done, value } = await reader.read();
					if (done) break;

					const chunk = decoder.decode(value);
					const lines = chunk.split('\n\n');
					for (const line of lines) {
						if (line.startsWith('data: ')) {
							const data = JSON.parse(line.slice(6));
							processingProgress = data.progress;
							uploadStatus = `Uploading ${file.name}: 100% | Processing: ${processingProgress.toFixed(2)}%`;
						}
					}
				}

				uploadStatus = `Uploaded and processed ${file.name}`;
				files = [...files, { name: file.name, type: file.type }];
				dispatch('upload', [{ name: file.name, type: file.type }]);
			} catch (error) {
				console.error('Error uploading file:', error);
				uploadStatus = `Error uploading ${file.name}: ${error.message}`;
			}
		}

		uploading = false;
	}
</script>

<div class="">
	<label class="btn btn-primary">
		<svg
			width="24px"
			height="24px"
			stroke-width="1.5"
			viewBox="0 0 24 24"
			fill="none"
			xmlns="http://www.w3.org/2000/svg"
			color="#ffffff"
		>
			<!-- SVG path data here -->
		</svg>
		<input
			type="file"
			multiple
			on:change={handleFileSelect}
			class="hidden"
			accept=".pdf,.txt,.doc,.docx,.csv,.json"
		/>
		Upload Files
	</label>
	{#if uploading}
		<div class="mt-4 bg-base-200 p-4 rounded-lg shadow-md" transition:fade>
			<p class="mb-2">{uploadStatus}</p>
			<div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
				<div
					class="bg-blue-600 h-2.5 rounded-full transition-all duration-300 ease-in-out"
					style="width: {uploadProgress}%"
				></div>
			</div>
			<div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700 mt-2">
				<div
					class="bg-green-600 h-2.5 rounded-full transition-all duration-300 ease-in-out"
					style="width: {processingProgress}%"
				></div>
			</div>
		</div>
	{/if}
	{#if files.length > 0}
		<ul class="mt-4 space-y-2">
			{#each files as file}
				<li class="bg-base-200 p-2 rounded-md flex items-center justify-between">
					<span>{file.name}</span>
					<span class="text-sm text-gray-500">({file.type})</span>
				</li>
			{/each}
		</ul>
	{/if}
</div>

================
File: src/lib/components/FloatingActionButton.svelte
================
<script>
	import { createEventDispatcher } from 'svelte';

	const dispatch = createEventDispatcher();
	export let isLoading;
</script>

<div class="fixed bottom-8 right-8 flex flex-col gap-4 z-50">
	<button
		class="btn btn-lg btn-primary w-48"
		on:click={() => dispatch('continue')}
		disabled={isLoading}
	>
		Continue
	</button>
	<button
		class="btn btn-lg btn-secondary w-48"
		on:click={() => dispatch('question')}
		disabled={isLoading}
	>
		Ask Question
	</button>
</div>

================
File: src/lib/components/Navbar.svelte
================
<!-- src/lib/components/Navbar.svelte -->
<script>
	import ThemeToggle from './ThemeToggle.svelte';

	export let toggleSidebar;
</script>

<nav class="bg-base-200 p-4 flex justify-between items-center fixed top-0 left-0 right-0 z-50">
	<div class="flex items-center">
		<button class="lg:hidden mr-2" on:click={toggleSidebar}>
			<svg
				xmlns="http://www.w3.org/2000/svg"
				class="h-6 w-6"
				fill="none"
				viewBox="0 0 24 24"
				stroke="currentColor"
			>
				<path
					stroke-linecap="round"
					stroke-linejoin="round"
					stroke-width="2"
					d="M4 6h16M4 12h16M4 18h16"
				/>
			</svg>
		</button>
		<h1 class="text-2xl font-bold text-primary">GuruGPT</h1>
	</div>
	<ThemeToggle />
</nav>

================
File: src/lib/components/ProgressBar.svelte
================
<script>
	export let progress;
</script>

<div class="w-full bg-gray-200 rounded-full h-2.5 mb-4 dark:bg-gray-700">
	<div
		class="bg-blue-600 h-2.5 rounded-full transition-all duration-300 ease-in-out"
		style="width: {progress}%"
	></div>
</div>
<p class="text-center text-sm text-gray-500 dark:text-gray-400">
	{progress.toFixed(1)}% complete
</p>

================
File: src/lib/components/QuestionModal.svelte
================
<script>
	import { createEventDispatcher } from 'svelte';

	export let show = false;
	let question = '';
	const dispatch = createEventDispatcher();

	function handleSubmit() {
		dispatch('submit', question);
		question = '';
	}
</script>

{#if show}
	<div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
		<div class="bg-base-100 p-6 rounded-lg w-96">
			<h2 class="text-xl font-bold mb-4">Ask a Question</h2>
			<textarea
				bind:value={question}
				class="w-full h-32 p-2 mb-4 border rounded"
				placeholder="Type your question here..."
			></textarea>
			<div class="flex justify-end">
				<button class="btn btn-primary mr-2" on:click={handleSubmit}>Submit</button>
				<button class="btn" on:click={() => (show = false)}>Cancel</button>
			</div>
		</div>
	</div>
{/if}

================
File: src/lib/components/TableOfContents.svelte
================
<!-- src/lib/components/TableOfContents.svelte -->
<script>
	export let conversation = [];

	function jumpToChapter(index) {
		const element = document.querySelector(`[data-index="${index}"]`);
		if (element) {
			element.scrollIntoView({ behavior: 'smooth' });
		}
	}
</script>

<nav class="p-4">
	<h2 class="text-xl font-bold mb-4">Table of Contents</h2>
	{#if conversation.length > 0}
		<ul class="space-y-2">
			{#each conversation as item, index}
				<li>
					<button
						class="text-left w-full p-2 rounded hover:bg-base-300 transition-colors"
						on:click={() => jumpToChapter(index)}
					>
						{item.title}
					</button>
				</li>
			{/each}
		</ul>
	{:else}
		<p class="text-sm text-base-content/70">
			No content yet. Start a lesson to see the table of contents.
		</p>
	{/if}
</nav>

================
File: src/lib/components/ThemeToggle.svelte
================
<script>
	import { theme } from '$lib/utils/theme';

	function toggleTheme() {
		$theme = $theme === 'dark' ? 'light' : 'dark';
	}
</script>

<label class="swap swap-rotate">
	<input type="checkbox" on:change={toggleTheme} checked={$theme === 'dark'} />
	<svg class="swap-on fill-current w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
		><path
			d="M5.64,17l-.71.71a1,1,0,0,0,0,1.41,1,1,0,0,0,1.41,0l.71-.71A1,1,0,0,0,5.64,17ZM5,12a1,1,0,0,0-1-1H3a1,1,0,0,0,0,2H4A1,1,0,0,0,5,12Zm7-7a1,1,0,0,0,1-1V3a1,1,0,0,0-2,0V4A1,1,0,0,0,12,5ZM5.64,7.05a1,1,0,0,0,.7.29,1,1,0,0,0,.71-.29,1,1,0,0,0,0-1.41l-.71-.71A1,1,0,0,0,4.93,6.34Zm12,.29a1,1,0,0,0,.7-.29l.71-.71a1,1,0,1,0-1.41-1.41L17,5.64a1,1,0,0,0,0,1.41A1,1,0,0,0,17.66,7.34ZM21,11H20a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm-9,8a1,1,0,0,0-1,1v1a1,1,0,0,0,2,0V20A1,1,0,0,0,12,19ZM18.36,17A1,1,0,0,0,17,18.36l.71.71a1,1,0,0,0,1.41,0,1,1,0,0,0,0-1.41ZM12,6.5A5.5,5.5,0,1,0,17.5,12,5.51,5.51,0,0,0,12,6.5Zm0,9A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z"
		/></svg
	>
	<svg class="swap-off fill-current w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
		><path
			d="M21.64,13a1,1,0,0,0-1.05-.14,8.05,8.05,0,0,1-3.37.73A8.15,8.15,0,0,1,9.08,5.49a8.59,8.59,0,0,1,.25-2A1,1,0,0,0,8,2.36,10.14,10.14,0,1,0,22,14.05,1,1,0,0,0,21.64,13Zm-9.5,6.69A8.14,8.14,0,0,1,7.08,5.22v.27A10.15,10.15,0,0,0,17.22,15.63a9.79,9.79,0,0,0,2.1-.22A8.11,8.11,0,0,1,12.14,19.73Z"
		/></svg
	>
</label>

================
File: src/lib/index.ts
================
// place files you want to import through the `$lib` alias in this folder.

================
File: src/lib/utils/markdown.js
================
// src/lib/utils/markdown.js
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import hljs from 'highlight.js';

marked.setOptions({
	highlight: function (code, lang) {
		if (lang && hljs.getLanguage(lang)) {
			return hljs.highlight(lang, code).value;
		} else {
			return hljs.highlightAuto(code).value;
		}
	}
});

export function parseMarkdown(content) {
	const rawHtml = marked(content);
	return DOMPurify.sanitize(rawHtml);
}

================
File: src/lib/utils/theme.js
================
import { writable } from 'svelte/store';

// Initialize the theme based on user's preference or default to 'dark'
const userTheme = typeof window !== 'undefined' ? window.localStorage.getItem('theme') : null;
export const theme = writable(userTheme || 'dark');

// Subscribe to changes and update localStorage
if (typeof window !== 'undefined') {
	theme.subscribe((value) => {
		window.localStorage.setItem('theme', value);
	});
}

================
File: src/lib/vectorStore.js
================
// src/lib/vectorStore.js
import { createClient } from '@supabase/supabase-js';
import { OpenAIEmbeddings } from '@langchain/openai';

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

const embeddings = new OpenAIEmbeddings();

export async function addDocumentToVectorStore(document) {
	const { content, metadata } = document;
	const embedding = await embeddings.embedQuery(content);

	const { data, error } = await supabase
		.from('documents')
		.insert({ content, metadata, embedding })
		.select();

	if (error) throw error;
	return data[0];
}

export async function getRelevantDocuments(query, match_threshold = 0.78, match_count = 10) {
	const queryEmbedding = await embeddings.embedQuery(query);

	const { data, error } = await supabase.rpc('match_documents', {
		query_embedding: queryEmbedding,
		match_threshold,
		match_count
	});

	if (error) throw error;
	return data;
}

================
File: src/routes/+layout.svelte
================
<!-- src/routes/+layout.svelte -->
<script>
	import '../app.pcss';
	import { theme } from '$lib/utils/theme';
	import Navbar from '$lib/components/Navbar.svelte';
	import TableOfContents from '$lib/components/TableOfContents.svelte';
	import { onMount } from 'svelte';
	import { writable } from 'svelte/store';
	import { setContext } from 'svelte';

	let sidebarOpen = false;

	function toggleSidebar() {
		sidebarOpen = !sidebarOpen;
	}

	onMount(() => {
		document.documentElement.setAttribute('data-theme', $theme);
	});

	$: if (typeof document !== 'undefined') {
		document.documentElement.setAttribute('data-theme', $theme);
	}

	const conversationStore = writable([]);

	// Function to update the conversation store
	function updateConversation(newConversation) {
		conversationStore.set(newConversation);
	}

	// Set the context for child components
	setContext('conversation', {
		conversationStore,
		updateConversation
	});
</script>

<div class="min-h-screen bg-base-100 text-base-content flex flex-col" data-theme={$theme}>
	<Navbar {toggleSidebar} />
	<div class="flex flex-1 pt-16">
		<!-- Sidebar -->
		<aside
			class="bg-base-200 w-64 fixed h-full overflow-auto transition-transform duration-300 ease-in-out lg:translate-x-0 {sidebarOpen
				? 'translate-x-0'
				: '-translate-x-full'} z-30"
		>
			<TableOfContents conversation={$conversationStore} />
		</aside>

		<!-- Main Content -->
		<main class="flex-1 p-4 lg:ml-64">
			<slot {updateConversation} />
		</main>
	</div>
</div>

<style>
	:global(html, body) {
		height: 100%;
	}
</style>

================
File: src/routes/+page.svelte
================
<script>
	import { onMount, getContext } from 'svelte';
	import ChapterCard from '$lib/components/ChapterCard.svelte';
	import ProgressBar from '$lib/components/ProgressBar.svelte';
	import FloatingActionButton from '$lib/components/FloatingActionButton.svelte';
	import QuestionModal from '$lib/components/QuestionModal.svelte';
	import FileUpload from '$lib/components/FileUpload.svelte';

	const { conversationStore, updateConversation } = getContext('conversation');

	let topic = '';
	let conversation = [];
	let isLoading = false;
	let inputElement;
	let currentChapter = 0;
	let progress = 0;
	let showQuestionModal = false;
	let uploadedFiles = [];

	async function getAIResponse(prompt, references = []) {
		console.log('Getting AI response for prompt:', prompt);
		isLoading = true;
		progress = 0;
		try {
			const response = await fetch('/api/openai', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({ prompt, references })
			});

			if (!response.ok) {
				throw new Error(`Failed to get AI response: ${response.statusText}`);
			}

			const reader = response.body.getReader();
			const decoder = new TextDecoder();
			let content = '';
			let responseReferences = [];
			let buffer = '';

			while (true) {
				const { value, done } = await reader.read();
				if (done) break;

				buffer += decoder.decode(value, { stream: true });
				const lines = buffer.split('\n\n');
				buffer = lines.pop() || '';

				for (const line of lines) {
					if (line.startsWith('data: ')) {
						try {
							const data = JSON.parse(line.slice(6));
							content = data.content || content;
							progress = data.progress || progress;
							if (data.references) {
								responseReferences = data.references;
							}
							console.log('Received chunk:', { content, progress, references: responseReferences });
						} catch (parseError) {
							console.warn('Error parsing chunk:', parseError, 'Raw chunk:', line);
							// Continue processing other chunks
						}
					}
				}
			}

			// Process any remaining data in the buffer
			if (buffer.startsWith('data: ')) {
				try {
					const data = JSON.parse(buffer.slice(6));
					content = data.content || content;
					progress = data.progress || progress;
					if (data.references) {
						responseReferences = data.references;
					}
				} catch (parseError) {
					console.warn('Error parsing final chunk:', parseError, 'Raw chunk:', buffer);
				}
			}

			console.log('AI response completed:', { content, references: responseReferences });
			return { content, references: responseReferences };
		} catch (error) {
			console.error('Error fetching AI response:', error);
			throw error;
		} finally {
			isLoading = false;
		}
	}

	async function startLesson() {
		if (!topic) return;
		const { content, references } = await getAIResponse(
			`Provide a comprehensive introduction to the topic: ${topic}.`
		);
		conversation = [
			{
				role: 'chapter',
				title: `Chapter 1: Introduction to ${topic}`,
				content: content,
				references: references
			}
		];
	}

	async function continueLesson() {
		if (conversation.length === 0) return;
		const chapterNumber = conversation.filter((msg) => msg.role === 'chapter').length + 1;
		const { content, references } = await getAIResponse(
			`Continue the lesson on ${topic}. This should be Chapter ${chapterNumber}.`
		);
		conversation = [
			...conversation,
			{
				role: 'chapter',
				title: `Chapter ${chapterNumber}: ${extractTitle(content)}`,
				content: content,
				references: references
			}
		];
	}

	async function askQuestion(question) {
		if (!question) return;
		const { content, references } = await getAIResponse(
			`Answer the following question about ${topic}: "${question}"`
		);
		conversation = [
			...conversation,
			{
				role: 'qa',
				title: `Q&A: ${question}`,
				content: `Q: ${question}\n\nA: ${content}`,
				references: references
			}
		];
	}

	function extractTitle(content) {
		// Extract the first sentence or a reasonable title from the content
		const match = content.match(/^(.+?[.!?])\s/);
		return match ? match[1] : 'Untitled Section';
	}

	function summarizePreviousChapters(conversation, maxLength = 500) {
		let summary = '';
		for (let i = 0; i < conversation.length; i++) {
			if (conversation[i].role === 'ai') {
				const chapterContent = conversation[i].content.split('\n\n')[1]; // Get content after chapter title
				summary += `Chapter ${i + 1} summary: ${chapterContent.substring(0, 100)}...\n`;
			}
		}
		return summary.length > maxLength ? summary.substring(0, maxLength) + '...' : summary;
	}

	function handleKeydown(event) {
		if (isLoading || showQuestionModal) return;
		if (event.key === 'Enter' && !event.ctrlKey && document.activeElement !== inputElement) {
			event.preventDefault();
			continueLesson();
		} else if (event.key === 'Enter' && event.ctrlKey) {
			event.preventDefault();
			showQuestionModal = true;
		}
	}

	function handleQuestionSubmit(event) {
		const question = event.detail;
		askQuestion(question);
		showQuestionModal = false;
	}

	function handleFileUpload(event) {
		uploadedFiles = [...uploadedFiles, ...event.detail];
	}

	function toggleSidebar() {
		sidebarOpen = !sidebarOpen;
	}

	function handleInputKeydown(event) {
		if (event.key === 'Enter' && !isLoading) {
			event.preventDefault();
			startLesson();
		}
	}

	function jumpToChapter(chapterIndex) {
		const chapterElement = document.querySelector(`[data-chapter="${chapterIndex + 1}"]`);
		if (chapterElement) {
			chapterElement.scrollIntoView({ behavior: 'smooth' });
		}
	}

	$: {
		updateConversation(conversation);
	}

	onMount(() => {
		const savedTheme = localStorage.getItem('theme') || 'light';
		document.documentElement.setAttribute('data-theme', savedTheme);
	});
</script>

<svelte:head>
	<title>GuruGPT</title>
</svelte:head>

<QuestionModal bind:show={showQuestionModal} on:submit={handleQuestionSubmit} />

<svelte:window on:keydown={handleKeydown} />

<div class="flex flex-col min-h-screen bg-base-100">
	<main class="flex-grow container mx-auto p-4">
		<div class="flex flex-col lg:flex-row gap-8">
			<!-- Main Content -->
			<div class="flex-grow">
				<!-- Topic Input, File Upload, and Start Button -->
				<div class="flex flex-col sm:flex-row gap-4 mb-8 items-end">
					<input
						class="input input-bordered flex-1"
						bind:value={topic}
						placeholder="Enter a topic"
						on:keydown={handleInputKeydown}
						bind:this={inputElement}
					/>
					<FileUpload on:upload={handleFileUpload} />
					<button class="btn btn-primary" on:click={startLesson} disabled={isLoading}>
						Start Lesson
					</button>
				</div>

				<!-- Progress Indicator -->
				{#if isLoading}
					<div class="mb-8">
						<ProgressBar {progress} />
					</div>
				{/if}

				<!-- Welcome Message -->
				{#if conversation.length === 0}
					<div class="text-center py-12 bg-base-200 rounded-lg shadow-md">
						<h2 class="text-2xl font-bold mb-4">Welcome to GuruGPT!</h2>
						<p class="mb-4">Enter a topic above to start your personalized lesson.</p>
						<p>Upload relevant files to enhance your learning experience.</p>
					</div>
				{/if}

				<!-- Conversation / Chapters -->
				<div class="space-y-8">
					{#each conversation as message, index}
						<div data-chapter={index + 1}>
							<ChapterCard {message} chapterIndex={index + 1} />
							{#if message.references && message.references.length > 0}
								<div class="mt-4 bg-base-200 p-4 rounded-lg shadow-md">
									<h4 class="font-medium mb-2">References:</h4>
									<ul class="list-disc list-inside space-y-2">
										{#each message.references as ref}
											<li class="text-sm">
												<span class="font-medium">Score: {ref.similarity.toFixed(4)}</span>
												<br />
												<span class="text-xs">{ref.content.substring(0, 100)}...</span>
											</li>
										{/each}
									</ul>
								</div>
							{/if}
						</div>
					{/each}
				</div>
			</div>
		</div>
	</main>

	<!-- Floating Action Button -->
	{#if conversation.length > 0}
		<FloatingActionButton
			on:continue={continueLesson}
			on:question={() => (showQuestionModal = true)}
			{isLoading}
		/>
	{/if}
</div>

================
File: src/routes/api/openai/+server.js
================
// src/routes/api/openai/+server.js
import { json } from '@sveltejs/kit';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';
import { OpenAIEmbeddings } from '@langchain/openai';
import dotenv from 'dotenv';

dotenv.config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;
const openaiApiKey = process.env.OPENAI_API_KEY;

if (!supabaseUrl || !supabaseKey || !openaiApiKey) {
	console.error('Missing required environment variables');
	throw new Error('Missing required environment variables');
}

const openai = new OpenAI({ apiKey: openaiApiKey });
const supabase = createClient(supabaseUrl, supabaseKey);
const embeddings = new OpenAIEmbeddings({ openAIApiKey: openaiApiKey });

export async function POST({ request }) {
	const { prompt, model = 'gpt-4-turbo-preview', max_tokens = 2000 } = await request.json();

	try {
		console.log('Received prompt:', prompt);

		const encoder = new TextEncoder();
		const readable = new ReadableStream({
			async start(controller) {
				// Send initial progress
				controller.enqueue(encoder.encode(`data: ${JSON.stringify({ progress: 0 })}\n\n`));

				// Generate embedding for the query
				const [queryEmbedding] = await embeddings.embedDocuments([prompt]);
				controller.enqueue(encoder.encode(`data: ${JSON.stringify({ progress: 10 })}\n\n`));

				// Retrieve relevant documents from Supabase
				const { data: documents, error } = await supabase.rpc('match_documents', {
					query_embedding: queryEmbedding,
					match_threshold: 0.78,
					match_count: 5
				});

				if (error) throw error;
				controller.enqueue(encoder.encode(`data: ${JSON.stringify({ progress: 20 })}\n\n`));

				// Prepare context from retrieved documents
				const context = documents.map((doc) => doc.content).join('\n\n');
				console.log('Retrieved context:', context);
				controller.enqueue(encoder.encode(`data: ${JSON.stringify({ progress: 30 })}\n\n`));

				// Prepare messages for OpenAI
				const messages = [
					{
						role: 'system',
						content: 'You are a helpful assistant. Use the provided context to answer questions.'
					},
					{
						role: 'user',
						content: `Context: ${context}\n\nQuestion: ${prompt}`
					}
				];

				const stream = await openai.chat.completions.create({
					model,
					messages,
					max_tokens,
					temperature: 0.7,
					stream: true
				});

				let content = '';
				let totalTokens = 0;
				for await (const chunk of stream) {
					const token = chunk.choices[0]?.delta?.content || '';
					content += token;
					totalTokens++;
					const progress = Math.min(30 + (totalTokens / max_tokens) * 70, 100);
					controller.enqueue(
						encoder.encode(
							`data: ${JSON.stringify({ content, progress, references: documents })}\n\n`
						)
					);
				}
				controller.close();
			}
		});

		return new Response(readable, {
			headers: {
				'Content-Type': 'text/event-stream',
				'Cache-Control': 'no-cache',
				Connection: 'keep-alive'
			}
		});
	} catch (error) {
		console.error('Error in RAG process:', error);
		return json({ error: 'Failed to process request' }, { status: 500 });
	}
}

================
File: src/routes/api/upload/+server.js
================
// src/routes/api/upload/+server.js
import { json } from '@sveltejs/kit';
import { writeFile, mkdir, readFile } from 'fs/promises';
import { join } from 'path';
import { createClient } from '@supabase/supabase-js';
import { OpenAIEmbeddings } from '@langchain/openai';
import { v4 as uuidv4 } from 'uuid';
import dotenv from 'dotenv';
import { createReadStream, createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';
import { PDFExtract } from 'pdf.js-extract';

dotenv.config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;
const openaiApiKey = process.env.OPENAI_API_KEY;

if (!supabaseUrl || !supabaseKey || !openaiApiKey) {
	console.error('Missing required environment variables');
	throw new Error('Missing required environment variables');
}

const supabase = createClient(supabaseUrl, supabaseKey);
const embeddings = new OpenAIEmbeddings({ openAIApiKey: openaiApiKey });

const pdfExtract = new PDFExtract();

const CHUNK_SIZE = 1000;
const CHUNK_OVERLAP = 200;

async function extractTextFromPDF(filePath) {
	return new Promise((resolve, reject) => {
		pdfExtract.extract(filePath, {}, (err, data) => {
			if (err) return reject(err);
			const text = data.pages
				.map((page) => page.content.map((item) => item.str).join(' '))
				.join('\n');
			resolve(text);
		});
	});
}

export async function POST({ request }) {
	console.log('Upload request received');
	const data = await request.formData();
	const file = data.get('file');

	if (!file) {
		console.error('No file uploaded');
		return json({ error: 'No file uploaded' }, { status: 400 });
	}

	const filename = file.name;
	const uploadDir = join(process.cwd(), 'uploads');
	const filePath = join(uploadDir, filename);

	try {
		await mkdir(uploadDir, { recursive: true });

		const fileStream = file.stream();
		const writeStream = createWriteStream(filePath);

		await pipeline(fileStream, writeStream);

		console.log(`File saved to: ${filePath}`);

		// Extract text content based on file type
		let fileContent;
		if (filename.toLowerCase().endsWith('.pdf')) {
			fileContent = await extractTextFromPDF(filePath);
		} else {
			fileContent = await readFile(filePath, 'utf-8');
		}

		// Split the content into smaller chunks
		const textSplitter = new RecursiveCharacterTextSplitter({
			chunkSize: CHUNK_SIZE,
			chunkOverlap: CHUNK_OVERLAP
		});

		const docs = await textSplitter.createDocuments([fileContent]);

		// Set up a readable stream for progress updates
		const encoder = new TextEncoder();
		const readable = new ReadableStream({
			async start(controller) {
				for (let i = 0; i < docs.length; i++) {
					const chunk = docs[i];

					// Sanitize the content
					const sanitizedContent = sanitizeContent(chunk.pageContent);

					// Generate embedding for the chunk
					const [embedding] = await embeddings.embedDocuments([sanitizedContent]);

					// Store chunk in Supabase
					const { data: document, error } = await supabase
						.from('documents')
						.insert({
							id: uuidv4(),
							content: sanitizedContent,
							metadata: {
								...chunk.metadata,
								filename,
								type: file.type,
								chunk: i + 1,
								totalChunks: docs.length
							},
							embedding
						})
						.select();

					if (error) {
						console.error(`Error storing chunk ${i + 1} in Supabase:`, error);
						throw error;
					}

					console.log(`Chunk ${i + 1}/${docs.length} processed and stored`);

					// Send progress update
					const progress = Math.round(((i + 1) / docs.length) * 100);
					controller.enqueue(encoder.encode(`data: ${JSON.stringify({ progress })}\n\n`));
				}
				controller.close();
			}
		});

		return new Response(readable, {
			headers: {
				'Content-Type': 'text/event-stream',
				'Cache-Control': 'no-cache',
				Connection: 'keep-alive'
			}
		});
	} catch (error) {
		console.error('Error processing file:', error);
		return json({ error: 'Could not process file' }, { status: 500 });
	}
}

async function readFileContent(filePath) {
	const buffer = await readFile(filePath);
	return buffer.toString('utf-8');
}

function sanitizeContent(content) {
	return content.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
}

================
File: svelte.config.js
================
import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	preprocess: vitePreprocess(),
	kit: {
		adapter: adapter(),
		csrf: {
			checkOrigin: false
		}
	}
};

export default config;

================
File: tailwind.config.js
================
import daisyui from 'daisyui';
import typography from '@tailwindcss/typography';

/** @type {import('tailwindcss').Config} */
export default {
	content: ['./src/**/*.{html,js,svelte,ts}'],
	theme: {
		extend: {}
	},
	plugins: [daisyui, typography],
	daisyui: {
		themes: ['light', 'dark']
	}
};

================
File: tsconfig.json
================
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://kit.svelte.dev/docs/configuration#alias
	// except $lib which is handled by https://kit.svelte.dev/docs/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}

================
File: vite.config.ts
================
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vite';

export default defineConfig({
	plugins: [sveltekit()],
	server: {
		fs: {
			strict: false
		}
	},
	optimizeDeps: {
		exclude: ['@supabase/supabase-js']
	}
});
